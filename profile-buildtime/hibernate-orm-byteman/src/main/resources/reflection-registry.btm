RULE track reflection registrations via class
CLASS com.oracle.svm.reflect.hosted.ReflectionDataBuilder
METHOD register(ConfigurationCondition, boolean, Class)
HELPER org.acme.byteman.ReflectionRegistryHelper
AT ENTRY
BIND
  numIterations = readCounter("numIterations");
  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
IF TRUE
DO
  # traceln(prefix + " register for reflection " + $3);
  trackReflectionRegistration(numIterations, $3);
ENDRULE

RULE track reflection registrations via method
CLASS com.oracle.svm.reflect.hosted.ReflectionDataBuilder
METHOD registerMethods
HELPER org.acme.byteman.ReflectionRegistryHelper
AT INVOKE Set.add
BIND
  numIterations = readCounter("numIterations");
  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
IF TRUE
DO
  # traceln(prefix + " register methods for reflection " + java.util.Arrays.toString($2));
  # traceln(prefix + " register methods for reflection for class " + $@[1]);
  trackReflectionRegistration(numIterations, $@[1]);
ENDRULE

RULE track reflection registrations via field
CLASS com.oracle.svm.reflect.hosted.ReflectionDataBuilder
METHOD registerFields
HELPER org.acme.byteman.ReflectionRegistryHelper
AT INVOKE Set.add 2
BIND
  numIterations = readCounter("numIterations");
  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
IF TRUE
DO
  # traceln(prefix + " register fields for reflection " + java.util.Arrays.toString($1));
  # traceln(prefix + " register fields for reflection for class " + $@[1]);
  trackReflectionRegistration(numIterations, $@[1]);
ENDRULE

RULE track configuration parsing
CLASS com.oracle.svm.hosted.config.ConfigurationParserUtils
METHOD doParseAndRegister
HELPER org.acme.byteman.ReflectionRegistryHelper
AT ENTRY
IF TRUE
DO
  trackConfigurationParsing($3);
ENDRULE

RULE track bundle
CLASS com.oracle.svm.core.jdk.localization.LocalizationSupport
METHOD prepareBundle
HELPER org.acme.byteman.ReflectionRegistryHelper
AT ENTRY
BIND
  numIterations = readCounter("numIterations");
  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
IF TRUE
DO
  # traceln(prefix + " prepare bundle " + $1.toString());
  trackBundle($1);
ENDRULE

#RULE add root method
#CLASS com.oracle.graal.pointsto.PointsToAnalysis
#METHOD addRootMethod(AnalysisMethod, boolean)
#AT ENTRY
#BIND
#  numIterations = readCounter("numIterations");
#  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
#IF TRUE
#DO
#  traceln(prefix + " add root method " + $1.toString());
#ENDRULE

RULE parse bytecode
CLASS com.oracle.graal.pointsto.flow.AnalysisParsedGraph
METHOD parseBytecode
HELPER org.acme.byteman.ReflectionRegistryHelper
AT ENTRY
BIND
  numIterations = readCounter("numIterations");
  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
IF TRUE
DO
  # traceln(prefix + " parse bytecode " + $2.toString());
  trackAnalysisMethod($2.format("%H.%n"));
ENDRULE

RULE static invoke
CLASS com.oracle.graal.pointsto.flow.StaticInvokeTypeFlow
METHOD update
HELPER org.acme.byteman.ReflectionRegistryHelper
AT ENTRY
BIND
  numIterations = readCounter("numIterations");
  prefix = "(" + Thread.currentThread().getName() + ") [run-analysis-" + numIterations + "]";
IF TRUE
DO
  # traceln(prefix + " static invoke " + $this.source.toString() + " -> " + $this.targetMethod.format("%H.%n"));
  trackStaticInvoke($this.source.toString(), $this.targetMethod.format("%H.%n"));
ENDRULE

RULE print summary reflection registry
CLASS com.oracle.graal.pointsto.PointsToAnalysis
METHOD runAnalysis
HELPER org.acme.byteman.ReflectionRegistryHelper
AT EXIT
IF TRUE
DO
  printSummary();
ENDRULE
